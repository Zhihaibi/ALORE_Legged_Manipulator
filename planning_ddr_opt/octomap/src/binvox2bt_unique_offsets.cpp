/*
 * OctoMap - An Efficient Probabilistic 3D Mapping Framework Based on Octrees
 * https://octomap.github.io/
 *
 * Copyright (c) 2009-2013, K.M. Wurm and A. Hornung, University of Freiburg
 * All rights reserved.
 * License: New BSD
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of the University of Freiburg nor the names of its
 *       contributors may be used to endorse or promote products derived from
 *       this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*!
* @file binvox2bt.cpp
* Read files generated by Patrick Min's 3D mesh voxelizer
* ("binvox", available at: http://www.cs.princeton.edu/~min/binvox/)
* and convert the voxel meshes to a single octree (.bt) file.
* This file is based on code from http://www.cs.princeton.edu/~min/binvox/read_binvox.cc
*
* Modified to allow a per-file offset via the command line.
*
* @author
*   S. Osswald, University of Freiburg, Copyright (C) 2010.
*   Modified by Sandilya Sai Garimella for per-file offsets.
* License: New BSD License

Example usage:
./binvox2bt_unique_offsets --mark-free --offset 1.0 2.0 3.0 model1.binvox --offset -1.0 0.5 0.0 model2.binvox -o merged.bt

*/

#ifndef M_PI_2
  #define M_PI_2 1.5707963267948966192E0
#endif

#include <string>
#include <fstream>
#include <iostream>
#include <vector>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <octomap/octomap.h>

using namespace std;
using namespace octomap;

namespace octomap {
  typedef unsigned char byte;
}

// Structure to hold per-file options
struct FileOptions {
  std::string filename;
  bool applyOffset;
  point3d offset;
};

int main(int argc, char **argv)
{
    // Global options that apply to all files (except offset is per file)
    bool mark_free = false;
    bool rotate = false;
    bool show_help = false;
    string output_filename;
    bool applyBBX = false;
    double minX = 0.0, minY = 0.0, minZ = 0.0;
    double maxX = 0.0, maxY = 0.0, maxZ = 0.0;

    // Vector to store each file and its associated offset settings:
    vector<FileOptions> fileOptions;
    // These variables hold the current per-file offset settings until a file is encountered.
    bool currentApplyOffset = false;
    point3d currentOffset(0.0, 0.0, 0.0);

    // Check for help request
    if(argc == 1) show_help = true;
    for (int i = 1; i < argc && !show_help; i++){
        if(strcmp(argv[i], "--help") == 0 || strcmp(argv[i], "-help") == 0 ||
           strcmp(argv[i], "--usage") == 0 || strcmp(argv[i], "-usage") == 0 ||
           strcmp(argv[i], "-h") == 0)
               show_help = true;
    }

    if(show_help) {
        cout << "Usage: " << argv[0] << " [OPTIONS] <binvox filenames>\n";
        cout << "\tOPTIONS:\n";
        cout << "\t -o <file>        Output filename (default: first input filename + .bt)\n";
        cout << "\t --mark-free      Mark not occupied cells as 'free' (default: unknown)\n";
        cout << "\t --rotate         Rotate left by 90 deg. to fix the coordinate system when exported from Webots\n";
        cout << "\t --bb <minx> <miny> <minz> <maxx> <maxy> <maxz>: force bounding box for OcTree\n";
        cout << "\t --offset <x> <y> <z>: add an offset to the final coordinates for the following file only\n";
        cout << "If more than one binvox file is given, the models are composed into a single octree.\n";
        exit(0);
    }

    // Parse command-line arguments
    for (int i = 1; i < argc; i++){
        string arg = argv[i];
        if(arg == "--mark-free"){
            mark_free = true;
        } else if(arg == "--no-mark-free"){
            mark_free = false;
        } else if(arg == "--rotate"){
            rotate = true;
        } else if(arg == "-o" && i + 1 < argc){
            i++;
            output_filename = argv[i];
        } else if(arg == "--bb" && i + 6 < argc){
            i++;
            minX = atof(argv[i]);
            i++;
            minY = atof(argv[i]);
            i++;
            minZ = atof(argv[i]);
            i++;
            maxX = atof(argv[i]);
            i++;
            maxY = atof(argv[i]);
            i++;
            maxZ = atof(argv[i]);
            applyBBX = true;
        } else if(arg == "--offset" && i + 3 < argc){
            // Set current offset settings for the next file
            currentApplyOffset = true;
            currentOffset(0) = (float) atof(argv[++i]);
            currentOffset(1) = (float) atof(argv[++i]);
            currentOffset(2) = (float) atof(argv[++i]);
        } else {
            // Anything else is assumed to be a filename.
            FileOptions fo;
            fo.filename = arg;
            fo.applyOffset = currentApplyOffset;
            fo.offset = currentOffset;
            fileOptions.push_back(fo);
            // Reset per-file offset settings so that --offset applies only to the next file.
            currentApplyOffset = false;
            currentOffset = point3d(0.0, 0.0, 0.0);
        }
    }

    if(fileOptions.empty()){
        cerr << "Error: No input files provided." << endl;
        exit(1);
    }
    if(output_filename.empty()){
        output_filename = fileOptions[0].filename + ".bt";
    }

    OcTree* tree = nullptr;

    // Process each binvox file
    for(const auto &fo : fileOptions){
        ifstream *input = new ifstream(fo.filename.c_str(), ios::in | ios::binary);
        if(!input->good()){
            cerr << "Error: Could not open input file " << fo.filename << "!" << endl;
            exit(1);
        } else {
            cout << "Reading binvox file " << fo.filename << "." << endl;
            if(output_filename.empty()){
                output_filename = fo.filename + ".bt";
            }
        }

        // Read header
        string line;
        *input >> line;  // Should be "#binvox"
        if(line.compare("#binvox") != 0){
            cout << "Error: first line reads [" << line << "] instead of [#binvox]" << endl;
            delete input;
            return 0;
        }
        int version;
        *input >> version;
        cout << "reading binvox version " << version << endl;

        size_t depth = 0, height = 0, width = 0;
        float tx = 0, ty = 0, tz = 0;
        float scale = 0;
        bool done = false;
        while(input->good() && !done){
            *input >> line;
            if(line.compare("data") == 0)
                done = true;
            else if(line.compare("dim") == 0){
                *input >> depth >> height >> width;
            }
            else if(line.compare("translate") == 0){
                *input >> tx >> ty >> tz;
            }
            else if(line.compare("scale") == 0){
                *input >> scale;
            }
            else{
                cout << "    unrecognized keyword [" << line << "], skipping" << endl;
                char c;
                do{
                    c = input->get();
                } while(input->good() && (c != '\n'));
            }
        }
        if(!done){
            cout << "    error reading header" << endl;
            return 0;
        }
        if(depth == 0){
            cout << "    missing dimensions in header" << endl;
            return 0;
        }

        size_t size = width * height * depth;
        int maxSide = std::max(std::max(width, height), depth);
        double res = double(scale) / double(maxSide);

        if(!tree){
            cout << "Generating octree with leaf size " << res << endl << endl;
            tree = new OcTree(res);
        }

        if(applyBBX){
            cout << "Bounding box for Octree: [" << minX << ", " << minY << ", " << minZ
                 << " - " << maxX << ", " << maxY << ", " << maxZ << "]" << endl;
        }
        if(fo.applyOffset){
            cout << "Offset on final map for file " << fo.filename << ": " << fo.offset << endl;
        }

        cout << "Read data: ";
        cout.flush();

        // Read voxel data
        octomap::byte value;
        octomap::byte count;
        size_t index = 0, end_index = 0;
        size_t nr_voxels = 0, nr_voxels_out = 0;

        input->unsetf(ios::skipws);  // read every byte now
        *input >> value;  // read the newline character

        while((end_index < size) && input->good()){
            *input >> value >> count;
            if(input->good()){
                end_index = index + count;
                if(end_index > size)
                    return 0;
                for(size_t j = index; j < end_index; j++){
                    // Display progress dots
                    if(j % (size / 20) == 0){
                        cout << ".";
                        cout.flush();
                    }
                    // Convert voxel index to voxel coordinates
                    size_t y = j % width;
                    size_t z = (j / width) % height;
                    size_t x = j / (width * height);

                    // Compute world coordinates (applying translation and scaling)
                    point3d endpoint(
                        static_cast<float>(x * res + tx + 0.000001),
                        static_cast<float>(y * res + ty + 0.000001),
                        static_cast<float>(z * res + tz + 0.000001)
                    );

                    if(rotate){
                        endpoint.rotate_IP(M_PI_2, 0.0, 0.0);
                    }
                    // Apply the file-specific offset if provided
                    if(fo.applyOffset){
                        endpoint += fo.offset;
                    }

                    // Only update node if within the bounding box (if defined)
                    if(!applyBBX || (endpoint(0) <= maxX && endpoint(0) >= minX &&
                                      endpoint(1) <= maxY && endpoint(1) >= minY &&
                                      endpoint(2) <= maxZ && endpoint(2) >= minZ)){
                        if(mark_free || value == 1){
                            tree->updateNode(endpoint, value == 1, true);
                        }
                    }
                    else{
                        nr_voxels_out++;
                    }
                }
                if(value) nr_voxels += count;
                index = end_index;
            }
        }
        cout << endl << endl;
        input->close();
        cout << "    read " << nr_voxels << " voxels, skipped " << nr_voxels_out
             << " (out of bounding box)" << endl << endl;
        delete input;
    } // end for each file

    // Finalize the octree
    cout << "Pruning octree" << endl << endl;
    tree->updateInnerOccupancy();
    tree->prune();

    cout << "Writing octree to " << output_filename << endl << endl;
    tree->writeBinary(output_filename.c_str());

    cout << "done" << endl << endl;
    return 0;
}
